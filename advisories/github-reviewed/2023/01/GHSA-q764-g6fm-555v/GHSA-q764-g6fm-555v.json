{
  "schema_version": "1.3.0",
  "id": "GHSA-q764-g6fm-555v",
  "modified": "2023-01-23T22:05:11Z",
  "published": "2023-01-23T22:05:11Z",
  "aliases": [
    "CVE-2023-23608"
  ],
  "summary": "Path traversal in spotipy",
  "details": "### Summary\nIf a malicious URI is passed to the library, the library can be tricked into performing an operation on a different API endpoint than intended.\n\n### Details\nThe [code Spotipy uses to parse URIs and URLs ](https://github.com/spotipy-dev/spotipy/blob/master/spotipy/client.py#L1942) accepts user data too liberally which allows a malicious user to insert arbitrary characters into the path that is used for API requests. Because it is possible to include `..`, an attacker can redirect for example a track lookup via `spotifyApi.track()` to an arbitrary API endpoint like playlists, but this is possible for other endpoints as well.\n\nBefore the security advisory feature was enabled on GitHub, I was already in contact with St√©phane Bruckert via e-mail, and he asked me to look into a potential fix. \n\nMy recommendation is to perform stricter parsing of URLs and URIs, which I implemented in the patch included at the end of the report. If you prefer, I can also invite you to a private fork of the repository.\n\n### PoC\nThe POC expects `SPOTIFY_CLIENT_ID` and `SPOTIFY_CLIENT_SECRET` environment variables to be set to authenticate against the API.\n```python\nimport spotipy\nfrom spotipy.oauth2 import SpotifyClientCredentials\n\n\ndef main():\n    spotifyApi = spotipy.Spotify(client_credentials_manager=SpotifyClientCredentials())\n\n    # This URL contains the example playlist ID from the spotify docs, a malicious\n    # playlist could instead contain a XSS payload in their title. A playlist with \n    # such a title was also included in the initial report via mail to maintainer.\n    malicious_spotify_url = 'spotify:track:../playlists/3cEYpjA9oz9GiPac4AsH4n'\n    \n\n    # Usage of the track function, expecting to get a non-user-controllable track name\n    # e.g. for displaying in a website.\n    # Our modified track uri however makes the library return the name of a playlist which\n    # may be created by anyone containing anything.\n    track = spotifyApi.track(malicious_spotify_url)\n\n    # Prints:\n    # 'Name of the track: Spotify Web API Testing playlist'\n    # A malicious playlist could also have an XSS payload as title, which would result in:\n    # 'Name of the track: <img src=x onerror=prompt(1)>'\n    print(f\"Name of the track: {track['name']}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Impact\nThe impact of this vulnerability depends heavily on what operations a client application performs when it handles a URI from a user and how it uses the responses it receives from the API.\n\n### Possible Patch\n\n#### Caviats of this patch\n* The ID parsing functionality now newly raises `ValueError` if it cannot parse an ID, instead of logging a warning or silently passing back whatever it received as input.\n    * **WARNING** I only adjusted unit tests to expect `ValueError` that didn't require a valid user session, other tests may also need adjustment\n* Unfortunately, I could not find conclusive documentation on what constitutes a valid Spotify username, but apparently some exist that contain alphanumeric characters, mine just contains numbers and the ones of newly created accounts seem to follow the base-62 scheme. You as developers probably have deeper insight into this, otherwise it probably will have to be discovered via bug reports if additional characters are valid as well.\n\n```\nFrom 30cf29b16e893dcac974dbd7481fb58a073b853c Mon Sep 17 00:00:00 2001\nFrom: Shaderbug <119610832+Shaderbug@users.noreply.github.com>\nDate: Tue, 10 Jan 2023 19:26:18 +0100\nSubject: [PATCH] Improve URL and URI handling\n\n---\n spotipy/client.py                            | 61 +++++++++++++++-----\n tests/integration/non_user_endpoints/test.py |  6 +-\n 2 files changed, 49 insertions(+), 18 deletions(-)\n\ndiff --git a/spotipy/client.py b/spotipy/client.py\nindex d7025a9..b094947 100644\n--- a/spotipy/client.py\n+++ b/spotipy/client.py\n@@ -6,6 +6,7 @@ __all__ = [\"Spotify\", \"SpotifyException\"]\n \n import json\n import logging\n+import re\n import warnings\n \n import requests\n@@ -96,6 +97,29 @@ class Spotify(object):\n         \"US\",\n         \"UY\"]\n \n+    # Spotify URI scheme defined in [1], and the ID format as base-62 in [2].\n+    #\n+    # Unfortunately the IANA specification is out of date and doesn't include the new types\n+    # show and episode. Additionally, for the user URI, it does not specify which characters\n+    # are valid for usernames, so the assumption is alphanumeric which coincidentially are also\n+    # the same ones base-62 uses.\n+    # In limited manual exploration this seems to hold true, as newly accounts are assigned an\n+    # identifier that looks like the base-62 of all other IDs, but some older accounts only have\n+    # numbers and even older ones seemed to have been allowed to freely pick this name.\n+    #\n+    # [1] https://www.iana.org/assignments/uri-schemes/prov/spotify\n+    # [2] https://developer.spotify.com/documentation/web-api/#spotify-uris-and-ids\n+    _regex_spotify_uri = r'^spotify:(?P<type>track|artist|album|playlist|show|episode|user):(?P<id>[0-9A-Za-z]+)$'\n+\n+    # Spotify URLs are defined at [1]. The assumption is made that they are all\n+    # pointing to open.spotify.com, so a regex is used to parse them as well,\n+    # instead of a more complex URL parsing function.\n+    #\n+    # [1] https://developer.spotify.com/documentation/web-api/#spotify-uris-and-ids\n+    _regex_spotify_url = r'^(http[s]?:\\/\\/)?open.spotify.com\\/(?P<type>track|artist|album|playlist|show|episode|user)\\/(?P<id>[0-9A-Za-z]+)(\\?.*)?$'\n+\n+    _regex_base62 = r'^[0-9A-Za-z]+$'\n+\n     def __init__(\n         self,\n         auth=None,\n@@ -1940,20 +1964,27 @@ class Spotify(object):\n         return path\n \n     def _get_id(self, type, id):\n-        fields = id.split(\":\")\n-        if len(fields) >= 3:\n-            if type != fields[-2]:\n-                logger.warning('Expected id of type %s but found type %s %s',\n-                               type, fields[-2], id)\n-            return fields[-1].split(\"?\")[0]\n-        fields = id.split(\"/\")\n-        if len(fields) >= 3:\n-            itype = fields[-2]\n-            if type != itype:\n-                logger.warning('Expected id of type %s but found type %s %s',\n-                               type, itype, id)\n-            return fields[-1].split(\"?\")[0]\n-        return id\n+        uri_match = re.search(Spotify._regex_spotify_uri, id)\n+        if uri_match is not None:\n+            uri_match_groups = uri_match.groupdict()\n+            if uri_match_groups['type'] != type:\n+                raise ValueError(\"Unexpected Spotify URI type.\")\n+            else:\n+                return uri_match_groups['id']\n+\n+        url_match = re.search(Spotify._regex_spotify_url, id)\n+        if url_match is not None:\n+            url_match_groups = url_match.groupdict()\n+            if url_match_groups['type'] != type:\n+                raise ValueError(\"Unexpected Spotify URL type.\")\n+            else:\n+                return url_match_groups['id']\n+\n+        # Raw identifiers might be passed, ensure they are also base-62\n+        if re.search(Spotify._regex_base62, id) is not None:\n+            return id\n+\n+        raise ValueError(\"Unsupported URL / URI\")\n \n     def _get_uri(self, type, id):\n         if self._is_uri(id):\n@@ -1962,7 +1993,7 @@ class Spotify(object):\n             return \"spotify:\" + type + \":\" + self._get_id(type, id)\n \n     def _is_uri(self, uri):\n-        return uri.startswith(\"spotify:\") and len(uri.split(':')) == 3\n+        return re.search(Spotify._regex_spotify_uri, uri) is not None\n \n     def _search_multiple_markets(self, q, limit, offset, type, markets, total):\n         if total and limit > total:\ndiff --git a/tests/integration/non_user_endpoints/test.py b/tests/integration/non_user_endpoints/test.py\nindex 96ee4da..116e1d9 100644\n--- a/tests/integration/non_user_endpoints/test.py\n+++ b/tests/integration/non_user_endpoints/test.py\n@@ -280,7 +280,7 @@ class AuthTestSpotipy(unittest.TestCase):\n         try:\n             self.spotify.track(self.bad_id)\n             self.assertTrue(False)\n-        except SpotifyException:\n+        except ValueError:\n             self.assertTrue(True)\n \n     def test_show_urn(self):\n@@ -296,7 +296,7 @@ class AuthTestSpotipy(unittest.TestCase):\n         self.assertTrue(show['name'] == 'Heavyweight')\n \n     def test_show_bad_urn(self):\n-        with self.assertRaises(SpotifyException):\n+        with self.assertRaises(ValueError):\n             self.spotify.show(\"bogus_urn\", market=\"US\")\n \n     def test_shows(self):\n@@ -333,7 +333,7 @@ class AuthTestSpotipy(unittest.TestCase):\n         self.assertTrue(episode['name'] == '#1 Buzz')\n \n     def test_episode_bad_urn(self):\n-        with self.assertRaises(SpotifyException):\n+        with self.assertRaises(ValueError):\n             self.spotify.episode(\"bogus_urn\", market=\"US\")\n \n     def test_episodes(self):\n-- \n2.34.1\n\n```",
  "severity": [
    {
      "type": "CVSS_V3",
      "score": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:N"
    }
  ],
  "affected": [
    {
      "package": {
        "ecosystem": "PyPI",
        "name": "spotipy"
      },
      "ranges": [
        {
          "type": "ECOSYSTEM",
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "2.22.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/spotipy-dev/spotipy/security/advisories/GHSA-q764-g6fm-555v"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/spotipy-dev/spotipy"
    }
  ],
  "database_specific": {
    "cwe_ids": [
      "CWE-22"
    ],
    "severity": "LOW",
    "github_reviewed": true
  }
}